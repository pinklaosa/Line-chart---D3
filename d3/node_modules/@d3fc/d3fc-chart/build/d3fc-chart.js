(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-scale'), require('d3-shape'), require('d3-path'), require('d3-array')) :
    typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-scale', 'd3-shape', 'd3-path', 'd3-array'], factory) :
    (global = global || self, factory(global.fc = global.fc || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Selection, d3Scale, d3Shape, d3Path, d3Array) { 'use strict';

    var d3Scale__default = 'default' in d3Scale ? d3Scale['default'] : d3Scale;
    var d3Shape__default = 'default' in d3Shape ? d3Shape['default'] : d3Shape;

    var createReboundMethod = ((target, source, name) => {
      const method = source[name];

      if (typeof method !== 'function') {
        throw new Error(`Attempt to rebind ${name} which isn't a function on the source object`);
      }

      return (...args) => {
        var value = method.apply(source, args);
        return value === source ? target : value;
      };
    });

    var rebind = ((target, source, ...names) => {
      for (const name of names) {
        target[name] = createReboundMethod(target, source, name);
      }

      return target;
    });

    const createTransform = transforms => name => transforms.reduce((name, fn) => name && fn(name), name);

    var rebindAll = ((target, source, ...transforms) => {
      const transform = createTransform(transforms);

      for (const name of Object.keys(source)) {
        const result = transform(name);

        if (result) {
          target[result] = createReboundMethod(target, source, name);
        }
      }

      return target;
    });

    var regexify = (strsOrRegexes => strsOrRegexes.map(strOrRegex => typeof strOrRegex === 'string' ? new RegExp(`^${strOrRegex}$`) : strOrRegex));

    var exclude = ((...exclusions) => {
      exclusions = regexify(exclusions);
      return name => exclusions.every(exclusion => !exclusion.test(name)) && name;
    });

    var include = ((...inclusions) => {
      inclusions = regexify(inclusions);
      return name => inclusions.some(inclusion => inclusion.test(name)) && name;
    });

    const capitalizeFirstLetter = str => str[0].toUpperCase() + str.slice(1);

    var prefix = (prefix => name => prefix + capitalizeFirstLetter(name));

    // "Caution: avoid interpolating to or from the number zero when the interpolator is used to generate
    // a string (such as with attr).
    // Very small values, when stringified, may be converted to scientific notation and
    // cause a temporarily invalid attribute or style property value.
    // For example, the number 0.0000001 is converted to the string "1e-7".
    // This is particularly noticeable when interpolating opacity values.
    // To avoid scientific notation, start or end the transition at 1e-6,
    // which is the smallest value that is not stringified in exponential notation."
    // - https://github.com/mbostock/d3/wiki/Transitions#d3_interpolateNumber
    const effectivelyZero = 1e-6; // Wrapper around d3's selectAll/data data-join, which allows decoration of the result.
    // This is achieved by appending the element to the enter selection before exposing it.
    // A default transition of fade in/out is also implicitly added but can be modified.

    var dataJoin = ((element, className) => {
      element = element || 'g';

      let key = (_, i) => i;

      let explicitTransition = null;

      const dataJoin = function (container, data) {
        data = data || (d => d);

        const implicitTransition = container.selection ? container : null;

        if (implicitTransition) {
          container = container.selection();
        }

        const selected = container.selectAll((d, i, nodes) => Array.from(nodes[i].childNodes).filter(node => node.nodeType === 1)).filter(className == null ? element : `${element}.${className}`);
        let update = selected.data(data, key);
        const enter = update.enter().append(element).attr('class', className);
        let exit = update.exit(); // automatically merge in the enter selection

        update = update.merge(enter); // if transitions are enabled apply a default fade in/out transition

        const transition = implicitTransition || explicitTransition;

        if (transition) {
          update = update.transition(transition).style('opacity', 1);
          enter.style('opacity', effectivelyZero);
          exit = exit.transition(transition).style('opacity', effectivelyZero);
        }

        exit.remove();

        update.enter = () => enter;

        update.exit = () => exit;

        return update;
      };

      dataJoin.element = (...args) => {
        if (!args.length) {
          return element;
        }

        element = args[0];
        return dataJoin;
      };

      dataJoin.className = (...args) => {
        if (!args.length) {
          return className;
        }

        className = args[0];
        return dataJoin;
      };

      dataJoin.key = (...args) => {
        if (!args.length) {
          return key;
        }

        key = args[0];
        return dataJoin;
      };

      dataJoin.transition = (...args) => {
        if (!args.length) {
          return explicitTransition;
        }

        explicitTransition = args[0];
        return dataJoin;
      };

      return dataJoin;
    });

    const identity = d => d;

    const axisBase = (orient, scale, custom = {}) => {
      let tickArguments = [10];
      let tickValues = null;

      let decorate = () => {};

      let tickFormat = null;
      let tickSizeOuter = 6;
      let tickSizeInner = 6;
      let tickPadding = 3;
      const svgDomainLine = d3Shape.line();

      const dataJoin$1 = dataJoin('g', 'tick').key(identity);

      const domainPathDataJoin = dataJoin('path', 'domain');

      const defaultLabelOffset = () => ({
        offset: [0, tickSizeInner + tickPadding]
      });

      const defaultTickPath = () => ({
        path: [[0, 0], [0, tickSizeInner]]
      });

      const labelOffset = custom.labelOffset || defaultLabelOffset;
      const tickPath = custom.tickPath || defaultTickPath; // returns a function that creates a translation based on
      // the bound data

      const containerTranslate = (scale, trans) => {
        let offset = 0;

        if (scale.bandwidth) {
          offset = scale.bandwidth() / 2;

          if (scale.round()) {
            offset = Math.round(offset);
          }
        }

        return d => trans(scale(d) + offset, 0);
      };

      const translate = (x, y) => isVertical() ? `translate(${y}, ${x})` : `translate(${x}, ${y})`;

      const pathTranspose = arr => isVertical() ? arr.map(d => [d[1], d[0]]) : arr;

      const isVertical = () => orient === 'left' || orient === 'right';

      const tryApply = (fn, args, defaultVal) => scale[fn] ? scale[fn].apply(scale, args) : defaultVal;

      const axis = selection => {
        if (selection.selection) {
          dataJoin$1.transition(selection);
          domainPathDataJoin.transition(selection);
        }

        selection.each((data, index, group) => {
          const element = group[index];
          const container = d3Selection.select(element);

          if (!element.__scale__) {
            container.attr('fill', 'none').attr('font-size', 10).attr('font-family', 'sans-serif').attr('text-anchor', orient === 'right' ? 'start' : orient === 'left' ? 'end' : 'middle');
          } // Stash a snapshot of the new scale, and retrieve the old snapshot.


          const scaleOld = element.__scale__ || scale;
          element.__scale__ = scale.copy();
          const ticksArray = tickValues == null ? tryApply('ticks', tickArguments, scale.domain()) : tickValues;
          const tickFormatter = tickFormat == null ? tryApply('tickFormat', tickArguments, identity) : tickFormat;
          const sign = orient === 'bottom' || orient === 'right' ? 1 : -1;

          const withSign = ([x, y]) => [x, sign * y]; // add the domain line


          const range = scale.range();
          const domainPathData = pathTranspose([[range[0], sign * tickSizeOuter], [range[0], 0], [range[1], 0], [range[1], sign * tickSizeOuter]]);
          const domainLine = domainPathDataJoin(container, [data]);
          domainLine.attr('d', svgDomainLine(domainPathData)).attr('stroke', '#000');
          const g = dataJoin$1(container, ticksArray);
          const labelOffsets = ticksArray.map((d, i) => labelOffset(d, i, ticksArray));
          const tickPaths = ticksArray.map((d, i) => tickPath(d, i, ticksArray)); // enter

          g.enter().attr('transform', containerTranslate(scaleOld, translate)).append('path').attr('stroke', '#000');
          g.enter().append('text').attr('transform', (d, i) => translate(...withSign(labelOffsets[i].offset))).attr('fill', '#000'); // exit

          g.exit().attr('transform', containerTranslate(scale, translate)); // update

          g.select('path').attr('visibility', (d, i) => tickPaths[i].hidden && 'hidden').attr('d', (d, i) => svgDomainLine(pathTranspose(tickPaths[i].path.map(withSign))));
          g.select('text').attr('visibility', (d, i) => labelOffsets[i].hidden && 'hidden').attr('transform', (d, i) => translate(...withSign(labelOffsets[i].offset))).attr('dy', () => {
            let offset = '0em';

            if (isVertical()) {
              offset = '0.32em';
            } else if (orient === 'bottom') {
              offset = '0.71em';
            }

            return offset;
          }).text(tickFormatter);
          g.attr('transform', containerTranslate(scale, translate));
          decorate(g, data, index);
        });
      };

      axis.tickFormat = (...args) => {
        if (!args.length) {
          return tickFormat;
        }

        tickFormat = args[0];
        return axis;
      };

      axis.tickSize = (...args) => {
        if (!args.length) {
          return tickSizeInner;
        }

        tickSizeInner = tickSizeOuter = Number(args[0]);
        return axis;
      };

      axis.tickSizeInner = (...args) => {
        if (!args.length) {
          return tickSizeInner;
        }

        tickSizeInner = Number(args[0]);
        return axis;
      };

      axis.tickSizeOuter = (...args) => {
        if (!args.length) {
          return tickSizeOuter;
        }

        tickSizeOuter = Number(args[0]);
        return axis;
      };

      axis.tickPadding = (...args) => {
        if (!args.length) {
          return tickPadding;
        }

        tickPadding = args[0];
        return axis;
      };

      axis.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return axis;
      };

      axis.scale = (...args) => {
        if (!args.length) {
          return scale;
        }

        scale = args[0];
        return axis;
      };

      axis.ticks = (...args) => {
        tickArguments = [...args];
        return axis;
      };

      axis.tickArguments = (...args) => {
        if (!args.length) {
          return tickArguments.slice();
        }

        tickArguments = args[0] == null ? [] : [...args[0]];
        return axis;
      };

      axis.tickValues = (...args) => {
        if (!args.length) {
          return tickValues.slice();
        }

        tickValues = args[0] == null ? [] : [...args[0]];
        return axis;
      };

      axis.orient = () => orient;

      return axis;
    };

    const axis = (orient, scale) => {
      let tickCenterLabel = false;

      const labelOffset = (tick, index, ticksArray) => {
        let x = 0;
        let y = base.tickSizeInner() + base.tickPadding();
        let hidden = false;

        if (tickCenterLabel) {
          const thisPosition = scale(tick);
          const nextPosition = index < ticksArray.length - 1 ? scale(ticksArray[index + 1]) : scale.range()[1];
          x = (nextPosition - thisPosition) / 2;
          y = base.tickPadding();
          hidden = index === ticksArray.length - 1 && thisPosition === nextPosition;
        }

        return {
          offset: [x, y],
          hidden
        };
      };

      const base = axisBase(orient, scale, {
        labelOffset
      });

      const axis = selection => {
        return base(selection);
      };

      axis.tickCenterLabel = (...args) => {
        if (!args.length) {
          return tickCenterLabel;
        }

        tickCenterLabel = args[0];
        return axis;
      };

      rebindAll(axis, base);
      return axis;
    };

    const axisTop = scale => axis('top', scale);
    const axisBottom = scale => axis('bottom', scale);
    const axisLeft = scale => axis('left', scale);
    const axisRight = scale => axis('right', scale);

    var store = (function () {
      var data = {};

      var store = function store(target) {
        for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          target[key].apply(null, data[key]);
        }

        return target;
      };

      for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
        names[_key] = arguments[_key];
      }

      var _loop = function _loop() {
        var name = _names[_i2];

        store[name] = function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          if (!args.length) {
            return data[name];
          }

          data[name] = args;
          return store;
        };
      };

      for (var _i2 = 0, _names = names; _i2 < _names.length; _i2++) {
        _loop();
      }

      return store;
    });

    // Adapted from https://github.com/substack/insert-css
    var css = "d3fc-group.cartesian-chart{width:100%;height:100%;overflow:hidden;display:grid;display:-ms-grid;grid-template-columns:minmax(1em,max-content) auto 1fr auto minmax(1em,max-content);-ms-grid-columns:minmax(1em,max-content) auto 1fr auto minmax(1em,max-content);grid-template-rows:minmax(1em,max-content) auto 1fr auto minmax(1em,max-content);-ms-grid-rows:minmax(1em,max-content) auto 1fr auto minmax(1em,max-content);}\nd3fc-group.cartesian-chart>.top-label{align-self:center;-ms-grid-column-align:center;justify-self:center;-ms-grid-row-align:center;grid-column:3;-ms-grid-column:3;grid-row:1;-ms-grid-row:1;}\nd3fc-group.cartesian-chart>.top-axis{height:2em;grid-column:3;-ms-grid-column:3;grid-row:2;-ms-grid-row:2;}\nd3fc-group.cartesian-chart>.left-label{align-self:center;-ms-grid-column-align:center;justify-self:center;-ms-grid-row-align:center;grid-column:1;-ms-grid-column:1;grid-row:3;-ms-grid-row:3;}\nd3fc-group.cartesian-chart>.left-axis{width:3em;grid-column:2;-ms-grid-column:2;grid-row:3;-ms-grid-row:3;}\nd3fc-group.cartesian-chart>.plot-area{overflow:hidden;grid-column:3;-ms-grid-column:3;grid-row:3;-ms-grid-row:3;}\nd3fc-group.cartesian-chart>.right-axis{width:3em;grid-column:4;-ms-grid-column:4;grid-row:3;-ms-grid-row:3;}\nd3fc-group.cartesian-chart>.right-label{align-self:center;-ms-grid-column-align:center;justify-self:center;-ms-grid-row-align:center;grid-column:5;-ms-grid-column:5;grid-row:3;-ms-grid-row:3;}\nd3fc-group.cartesian-chart>.bottom-axis{height:2em;grid-column:3;-ms-grid-column:3;grid-row:4;-ms-grid-row:4;}\nd3fc-group.cartesian-chart>.bottom-label{align-self:center;-ms-grid-column-align:center;justify-self:center;-ms-grid-row-align:center;grid-column:3;-ms-grid-column:3;grid-row:5;-ms-grid-row:5;}\nd3fc-group.cartesian-chart>.y-label{display:flex;transform:rotate(-90deg);width:1em;white-space:nowrap;justify-content:center;}";
    var styleElement = document.createElement('style');
    styleElement.setAttribute('type', 'text/css');
    document.querySelector('head').appendChild(styleElement);

    if (styleElement.styleSheet) {
      styleElement.styleSheet.cssText += css;
    } else {
      styleElement.textContent += css;
    }

    var functor = function functor(v) {
      return typeof v === 'function' ? v : function () {
        return v;
      };
    };

    var cartesianChart = (function () {
      var _getArguments = getArguments.apply(void 0, arguments),
          xScale = _getArguments.xScale,
          yScale = _getArguments.yScale,
          xAxis = _getArguments.xAxis,
          yAxis = _getArguments.yAxis;

      var chartLabel = functor('');
      var xLabel = functor('');
      var yLabel = functor('');
      var xAxisHeight = functor(null);
      var yAxisWidth = functor(null);
      var yOrient = functor('right');
      var xOrient = functor('bottom');
      var webglPlotArea = null;
      var canvasPlotArea = null;
      var svgPlotArea = null;
      var xAxisStore = store('tickFormat', 'ticks', 'tickArguments', 'tickSize', 'tickSizeInner', 'tickSizeOuter', 'tickValues', 'tickPadding', 'tickCenterLabel');

      var xDecorate = function xDecorate() {};

      var yAxisStore = store('tickFormat', 'ticks', 'tickArguments', 'tickSize', 'tickSizeInner', 'tickSizeOuter', 'tickValues', 'tickPadding', 'tickCenterLabel');

      var yDecorate = function yDecorate() {};

      var decorate = function decorate() {};

      var containerDataJoin = dataJoin('d3fc-group', 'cartesian-chart');
      var webglDataJoin = dataJoin('d3fc-canvas', 'gl-plot-area');
      var canvasDataJoin = dataJoin('d3fc-canvas', 'canvas-plot-area');
      var svgDataJoin = dataJoin('d3fc-svg', 'plot-area');
      var xAxisDataJoin = dataJoin('d3fc-svg', 'x-axis').key(function (d) {
        return d;
      });
      var yAxisDataJoin = dataJoin('d3fc-svg', 'y-axis').key(function (d) {
        return d;
      });
      var chartLabelDataJoin = dataJoin('div', 'chart-label');
      var xLabelDataJoin = dataJoin('div', 'x-label').key(function (d) {
        return d;
      });
      var yLabelDataJoin = dataJoin('div', 'y-label').key(function (d) {
        return d;
      });

      var propagateTransition = function propagateTransition(maybeTransition) {
        return function (selection) {
          return maybeTransition.selection ? selection.transition(maybeTransition) : selection;
        };
      };

      var cartesian = function cartesian(selection) {
        var transitionPropagator = propagateTransition(selection);
        selection.each(function (data, index, group) {
          var container = containerDataJoin(d3Selection.select(group[index]), [data]);
          container.enter().attr('auto-resize', '');
          chartLabelDataJoin(container, [xOrient(data)]).attr('class', function (d) {
            return d === 'top' ? 'chart-label bottom-label' : 'chart-label top-label';
          }).style('margin-bottom', function (d) {
            return d === 'top' ? 0 : '1em';
          }).style('margin-top', function (d) {
            return d === 'top' ? '1em' : 0;
          }).text(chartLabel(data));
          xLabelDataJoin(container, [xOrient(data)]).attr('class', function (d) {
            return "x-label ".concat(d, "-label");
          }).text(xLabel(data));
          yLabelDataJoin(container, [yOrient(data)]).attr('class', function (d) {
            return "y-label ".concat(d, "-label");
          }).text(yLabel(data));
          webglDataJoin(container, webglPlotArea ? [data] : []).attr('set-webgl-viewport', '').classed('plot-area', true).on('draw', function (d, i, nodes) {
            var canvas = d3Selection.select(nodes[i]).select('canvas').node();
            webglPlotArea.context(canvas.getContext('webgl')).xScale(xScale).yScale(yScale);
            webglPlotArea(d);
          });
          canvasDataJoin(container, canvasPlotArea ? [data] : []).classed('plot-area', true).on('draw', function (d, i, nodes) {
            var canvas = d3Selection.select(nodes[i]).select('canvas').node();
            canvasPlotArea.context(canvas.getContext('2d')).xScale(xScale).yScale(yScale);
            canvasPlotArea(d);
          });
          svgDataJoin(container, svgPlotArea ? [data] : []).on('draw', function (d, i, nodes) {
            svgPlotArea.xScale(xScale).yScale(yScale);
            transitionPropagator(d3Selection.select(nodes[i])).select('svg').call(svgPlotArea);
          });
          xAxisDataJoin(container, [xOrient(data)]).attr('class', function (d) {
            return "x-axis ".concat(d, "-axis");
          }).style('height', xAxisHeight(data)).on('measure', function (d, i, nodes) {
            var _event$detail = d3Selection.event.detail,
                width = _event$detail.width,
                height = _event$detail.height;

            if (d === 'top') {
              d3Selection.select(nodes[i]).select('svg').attr('viewBox', "0 ".concat(-height, " ").concat(width, " ").concat(height));
            }

            xScale.range([0, width]);
          }).on('draw', function (d, i, nodes) {
            var xAxisComponent = d === 'top' ? xAxis.top(xScale) : xAxis.bottom(xScale);
            xAxisComponent.decorate(xDecorate);
            transitionPropagator(d3Selection.select(nodes[i])).select('svg').call(xAxisStore(xAxisComponent));
          });
          yAxisDataJoin(container, [yOrient(data)]).attr('class', function (d) {
            return "y-axis ".concat(d, "-axis");
          }).style('width', yAxisWidth(data)).on('measure', function (d, i, nodes) {
            var _event$detail2 = d3Selection.event.detail,
                width = _event$detail2.width,
                height = _event$detail2.height;

            if (d === 'left') {
              d3Selection.select(nodes[i]).select('svg').attr('viewBox', "".concat(-width, " 0 ").concat(width, " ").concat(height));
            }

            yScale.range([height, 0]);
          }).on('draw', function (d, i, nodes) {
            var yAxisComponent = d === 'left' ? yAxis.left(yScale) : yAxis.right(yScale);
            yAxisComponent.decorate(yDecorate);
            transitionPropagator(d3Selection.select(nodes[i])).select('svg').call(yAxisStore(yAxisComponent));
          });
          container.each(function (d, i, nodes) {
            return nodes[i].requestRedraw();
          });
          decorate(container, data, index);
        });
      };

      var scaleExclusions = exclude(/range\w*/, // the scale range is set via the component layout
      /tickFormat/ // use axis.tickFormat instead (only present on linear scales)
      );
      rebindAll(cartesian, xScale, scaleExclusions, prefix('x'));
      rebindAll(cartesian, yScale, scaleExclusions, prefix('y'));
      rebindAll(cartesian, xAxisStore, prefix('x'));
      rebindAll(cartesian, yAxisStore, prefix('y'));

      cartesian.xOrient = function () {
        if (!arguments.length) {
          return xOrient;
        }

        xOrient = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return cartesian;
      };

      cartesian.yOrient = function () {
        if (!arguments.length) {
          return yOrient;
        }

        yOrient = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return cartesian;
      };

      cartesian.xDecorate = function () {
        if (!arguments.length) {
          return xDecorate;
        }

        xDecorate = arguments.length <= 0 ? undefined : arguments[0];
        return cartesian;
      };

      cartesian.yDecorate = function () {
        if (!arguments.length) {
          return yDecorate;
        }

        yDecorate = arguments.length <= 0 ? undefined : arguments[0];
        return cartesian;
      };

      cartesian.chartLabel = function () {
        if (!arguments.length) {
          return chartLabel;
        }

        chartLabel = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return cartesian;
      };

      cartesian.xLabel = function () {
        if (!arguments.length) {
          return xLabel;
        }

        xLabel = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return cartesian;
      };

      cartesian.yLabel = function () {
        if (!arguments.length) {
          return yLabel;
        }

        yLabel = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return cartesian;
      };

      cartesian.xAxisHeight = function () {
        if (!arguments.length) {
          return xAxisHeight;
        }

        xAxisHeight = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return cartesian;
      };

      cartesian.yAxisWidth = function () {
        if (!arguments.length) {
          return yAxisWidth;
        }

        yAxisWidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return cartesian;
      };

      cartesian.webglPlotArea = function () {
        if (!arguments.length) {
          return webglPlotArea;
        }

        webglPlotArea = arguments.length <= 0 ? undefined : arguments[0];
        return cartesian;
      };

      cartesian.canvasPlotArea = function () {
        if (!arguments.length) {
          return canvasPlotArea;
        }

        canvasPlotArea = arguments.length <= 0 ? undefined : arguments[0];
        return cartesian;
      };

      cartesian.svgPlotArea = function () {
        if (!arguments.length) {
          return svgPlotArea;
        }

        svgPlotArea = arguments.length <= 0 ? undefined : arguments[0];
        return cartesian;
      };

      cartesian.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return cartesian;
      };

      return cartesian;
    });

    var getArguments = function getArguments() {
      var defaultSettings = {
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity(),
        xAxis: {
          bottom: axisBottom,
          top: axisTop
        },
        yAxis: {
          right: axisRight,
          left: axisLeft
        }
      };

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args.length === 1 && !args[0].domain && !args[0].range) {
        // Settings object
        return Object.assign(defaultSettings, args[0]);
      } // xScale/yScale parameters


      return Object.assign(defaultSettings, {
        xScale: args[0] || defaultSettings.xScale,
        yScale: args[1] || defaultSettings.yScale
      });
    };

    var functor$1 = function functor(v) {
      return typeof v === 'function' ? v : function () {
        return v;
      };
    };

    var cartesianBase = (function (setPlotArea, defaultPlotArea) {
      return function () {
        var yLabel = functor$1('');
        var plotArea = defaultPlotArea;

        var decorate = function decorate() {};

        var cartesian = cartesianChart.apply(void 0, arguments);

        var cartesianBase = function cartesianBase(selection) {
          setPlotArea(cartesian, plotArea);
          cartesian.decorate(function (container, data, index) {
            container.enter().select('.x-label').style('height', '1em').style('line-height', '1em');
            var yOrientValue = cartesian.yOrient()(data);
            container.enter().append('div').attr('class', 'y-label-container').style('grid-column', yOrientValue === 'left' ? 1 : 5).style('-ms-grid-column', yOrientValue === 'left' ? 1 : 5).style('grid-row', 3).style('-ms-grid-row', 3).style('width', '1em').style('display', 'flex').style('align-items', 'center').style('justify-content', 'center').style('white-space', 'nowrap').append('div').attr('class', 'y-label').style('transform', 'rotate(-90deg)');
            container.select('.y-label-container>.y-label').text(yLabel);
            decorate(container, data, index);
          });
          selection.call(cartesian);
        };

        rebindAll(cartesianBase, cartesian, include(/^x/, /^y/, 'chartLabel'));

        cartesianBase.yLabel = function () {
          if (!arguments.length) {
            return yLabel;
          }

          yLabel = functor$1(arguments.length <= 0 ? undefined : arguments[0]);
          return cartesianBase;
        };

        cartesianBase.plotArea = function () {
          if (!arguments.length) {
            return plotArea;
          }

          plotArea = arguments.length <= 0 ? undefined : arguments[0];
          return cartesianBase;
        };

        cartesianBase.decorate = function () {
          if (!arguments.length) {
            return decorate;
          }

          decorate = arguments.length <= 0 ? undefined : arguments[0];
          return cartesianBase;
        };

        return cartesianBase;
      };
    });

    var functor$2 = (d => typeof d === 'function' ? d : () => d);

    // Checks that passed properties are 'defined', meaning that calling them with (d, i) returns non null values
    function defined() {
      const outerArguments = arguments;
      return function (d, i) {
        for (let c = 0, j = outerArguments.length; c < j; c++) {
          if (outerArguments[c](d, i) == null) {
            return false;
          }
        }

        return true;
      };
    }

    // determines the offset required along the cross scale based
    // on the series alignment
    var alignOffset = ((align, width) => {
      switch (align) {
        case 'left':
          return width / 2;

        case 'right':
          return -width / 2;

        default:
          return 0;
      }
    });

    var createBase = (initialValues => {
      const env = Object.assign({}, initialValues);

      const base = () => {};

      Object.keys(env).forEach(key => {
        base[key] = (...args) => {
          if (!args.length) {
            return env[key];
          }

          env[key] = args[0];
          return base;
        };
      });
      return base;
    });

    var xyBase = (() => {
      let baseValue = () => 0;

      let crossValue = d => d.x;

      let mainValue = d => d.y;

      let align = 'center';

      let bandwidth = () => 5;

      let orient = 'vertical';
      const base = createBase({
        decorate: () => {},
        defined: (d, i) => defined(baseValue, crossValue, mainValue)(d, i),
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = (d, i) => {
        const width = bandwidth(d, i);
        const offset = alignOffset(align, width);
        const xScale = base.xScale();
        const yScale = base.yScale();

        if (orient === 'vertical') {
          const y = yScale(mainValue(d, i), i);
          const y0 = yScale(baseValue(d, i), i);
          const x = xScale(crossValue(d, i), i) + offset;
          return {
            d,
            x,
            y,
            y0,
            width,
            height: y - y0,
            origin: [x, y],
            baseOrigin: [x, y0],
            transposedX: x,
            transposedY: y
          };
        } else {
          const y = xScale(mainValue(d, i), i);
          const y0 = xScale(baseValue(d, i), i);
          const x = yScale(crossValue(d, i), i) + offset;
          return {
            d,
            x,
            y,
            y0,
            width,
            height: y - y0,
            origin: [y, x],
            baseOrigin: [y0, x],
            transposedX: y,
            transposedY: x
          };
        }
      };

      base.xValues = () => orient === 'vertical' ? [crossValue] : [baseValue, mainValue];

      base.yValues = () => orient !== 'vertical' ? [crossValue] : [baseValue, mainValue];

      base.baseValue = (...args) => {
        if (!args.length) {
          return baseValue;
        }

        baseValue = functor$2(args[0]);
        return base;
      };

      base.crossValue = (...args) => {
        if (!args.length) {
          return crossValue;
        }

        crossValue = functor$2(args[0]);
        return base;
      };

      base.mainValue = (...args) => {
        if (!args.length) {
          return mainValue;
        }

        mainValue = functor$2(args[0]);
        return base;
      };

      base.bandwidth = (...args) => {
        if (!args.length) {
          return bandwidth;
        }

        bandwidth = functor$2(args[0]);
        return base;
      };

      base.align = (...args) => {
        if (!args.length) {
          return align;
        }

        align = args[0];
        return base;
      };

      base.orient = (...args) => {
        if (!args.length) {
          return orient;
        }

        orient = args[0];
        return base;
      };

      return base;
    });

    const red = '#c60';
    const green = '#6c0';
    const black = '#000';
    const gray = '#ddd';
    const darkGray = '#999';
    var colors = {
      red,
      green,
      black,
      gray,
      darkGray
    };

    var seriesSvgLine = (() => {
      const base = xyBase();
      const lineData = d3Shape.line().x((d, i) => base.values(d, i).transposedX).y((d, i) => base.values(d, i).transposedY);
      const join = dataJoin('path', 'line');

      const line = selection => {
        if (selection.selection) {
          join.transition(selection);
        }

        lineData.defined(base.defined());
        selection.each((data, index, group) => {
          const path = join(d3Selection.select(group[index]), [data]);
          path.enter().attr('fill', 'none').attr('stroke', colors.black);
          path.attr('d', lineData);
          base.decorate()(path, data, index);
        });
      };

      rebindAll(line, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(line, join, 'key');
      rebind(line, lineData, 'curve');
      return line;
    });

    var seriesCanvasLine = (() => {
      const base = xyBase();
      const lineData = d3Shape.line().x((d, i) => base.values(d, i).transposedX).y((d, i) => base.values(d, i).transposedY);

      const line = data => {
        const context = lineData.context();
        context.beginPath();
        context.strokeStyle = colors.black;
        context.fillStyle = 'transparent';
        base.decorate()(context, data);
        lineData.defined(base.defined())(data);
        context.fill();
        context.stroke();
        context.closePath();
      };

      rebindAll(line, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(line, lineData, 'curve', 'context');
      return line;
    });

    var cartesian = cartesianBase(function (cartesian, plotArea) {
      return cartesian.svgPlotArea(plotArea);
    }, seriesSvgLine);

    var cartesian$1 = cartesianBase(function (cartesian, plotArea) {
      return cartesian.canvasPlotArea(plotArea);
    }, seriesCanvasLine);

    exports.chartCanvasCartesian = cartesian$1;
    exports.chartCartesian = cartesianChart;
    exports.chartSvgCartesian = cartesian;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
