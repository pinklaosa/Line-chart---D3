(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.fcWebglAS = {}));
}(this, function (exports) { 'use strict';

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var hasBigInt64 = typeof BigUint64Array !== "undefined";
  var thisPtr = Symbol();
  /** Gets a string from an U32 and an U16 view on a memory. */

  function getStringImpl(U32, U16, ptr) {
    var dataLength = U32[ptr >>> 2];
    var dataOffset = ptr + 4 >>> 1;
    var dataRemain = dataLength;
    var parts = [];
    var chunkSize = 1024;

    while (dataRemain > chunkSize) {
      var last = U16[dataOffset + chunkSize - 1];
      var size = last >= 0xD800 && last < 0xDC00 ? chunkSize - 1 : chunkSize;
      var part = U16.subarray(dataOffset, dataOffset += size);
      parts.push(String.fromCharCode.apply(String, part));
      dataRemain -= size;
    }

    return parts.join("") + String.fromCharCode.apply(String, U16.subarray(dataOffset, dataOffset + dataRemain));
  }
  /** Prepares the base module prior to instantiation. */


  function preInstantiate(imports) {
    var baseModule = {};

    function getString(memory, ptr) {
      if (!memory) return "<yet unknown>";
      var buffer = memory.buffer;
      return getStringImpl(new Uint32Array(buffer), new Uint16Array(buffer), ptr);
    } // add common imports used by stdlib for convenience


    var env = imports.env = imports.env || {};

    env.abort = env.abort || function abort(mesg, file, line, colm) {
      var memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported

      throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
    };

    env.trace = env.trace || function trace(mesg, n) {
      var memory = baseModule.memory || env.memory;
      console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
    };

    imports.Math = imports.Math || Math;
    imports.Date = imports.Date || Date;
    return baseModule;
  }
  /** Prepares the final module once instantiation is complete. */


  function postInstantiate(baseModule, instance) {
    var rawExports = instance.exports;
    var memory = rawExports.memory;
    var memory_allocate = rawExports["memory.allocate"];
    var memory_fill = rawExports["memory.fill"];
    var memory_free = rawExports["memory.free"];
    var table = rawExports.table;

    var setargc = rawExports._setargc || function () {}; // Provide views for all sorts of basic values


    var buffer, I8, U8, I16, U16, I32, U32, F32, F64, I64, U64;
    /** Updates memory views if memory has grown meanwhile. */

    function checkMem() {
      // see: https://github.com/WebAssembly/design/issues/1210
      if (buffer !== memory.buffer) {
        buffer = memory.buffer;
        I8 = new Int8Array(buffer);
        U8 = new Uint8Array(buffer);
        I16 = new Int16Array(buffer);
        U16 = new Uint16Array(buffer);
        I32 = new Int32Array(buffer);
        U32 = new Uint32Array(buffer);

        if (hasBigInt64) {
          I64 = new BigInt64Array(buffer);
          U64 = new BigUint64Array(buffer);
        }

        F32 = new Float32Array(buffer);
        F64 = new Float64Array(buffer);
      }
    }

    checkMem();
    /** Allocates a new string in the module's memory and returns its pointer. */

    function newString(str) {
      var dataLength = str.length;
      var ptr = memory_allocate(4 + (dataLength << 1));
      var dataOffset = 4 + ptr >>> 1;
      checkMem();
      U32[ptr >>> 2] = dataLength;

      for (var i = 0; i < dataLength; ++i) {
        U16[dataOffset + i] = str.charCodeAt(i);
      }

      return ptr;
    }

    baseModule.newString = newString;
    /** Gets a string from the module's memory by its pointer. */

    function getString(ptr) {
      checkMem();
      return getStringImpl(U32, U16, ptr);
    }

    baseModule.getString = getString;

    function computeBufferSize(byteLength) {
      var HEADER_SIZE = 8;
      return 1 << 32 - Math.clz32(byteLength + HEADER_SIZE - 1);
    }
    /** Creates a new typed array in the module's memory and returns its pointer. */


    function newArray(view, length, unsafe) {
      var ctor = view.constructor;

      if (ctor === Function) {
        // TypedArray constructor created in memory
        ctor = view;
        view = null;
      } else {
        // TypedArray instance copied into memory
        if (length === undefined) length = view.length;
      }

      var elementSize = ctor.BYTES_PER_ELEMENT;
      if (!elementSize) throw Error("not a typed array");
      var byteLength = elementSize * length;
      var ptr = memory_allocate(12); // TypedArray header

      var buf = memory_allocate(computeBufferSize(byteLength)); // ArrayBuffer

      checkMem();
      U32[ptr >>> 2] = buf; // .buffer

      U32[ptr + 4 >>> 2] = 0; // .byteOffset

      U32[ptr + 8 >>> 2] = byteLength; // .byteLength

      U32[buf >>> 2] = byteLength; // .byteLength

      U32[buf + 4 >>> 2] = 0; // 0

      if (view) {
        new ctor(buffer, buf + 8, length).set(view);

        if (view.length < length && !unsafe) {
          var setLength = elementSize * view.length;
          memory_fill(buf + 8 + setLength, 0, byteLength - setLength);
        }
      } else if (!unsafe) {
        memory_fill(buf + 8, 0, byteLength);
      }

      return ptr;
    }

    baseModule.newArray = newArray;
    /** Gets a view on a typed array in the module's memory by its pointer. */

    function getArray(ctor, ptr) {
      var elementSize = ctor.BYTES_PER_ELEMENT;
      if (!elementSize) throw Error("not a typed array");
      checkMem();
      var buf = U32[ptr >>> 2];
      var byteOffset = U32[ptr + 4 >>> 2];
      var byteLength = U32[ptr + 8 >>> 2];
      return new ctor(buffer, buf + 8 + byteOffset, (byteLength - byteOffset) / elementSize);
    }

    baseModule.getArray = getArray;
    /** Frees a typed array in the module's memory. Must not be accessed anymore afterwards. */

    function freeArray(ptr) {
      checkMem();
      var buf = U32[ptr >>> 2];
      memory_free(buf);
      memory_free(ptr);
    }

    baseModule.freeArray = freeArray;
    /**
     * Creates a new function in the module's table and returns its pointer. Note that only actual
     * WebAssembly functions, i.e. as exported by the module, are supported.
     */

    function newFunction(fn) {
      if (typeof fn.original === "function") fn = fn.original;
      var index = table.length;
      table.grow(1);
      table.set(index, fn);
      return index;
    }

    baseModule.newFunction = newFunction;
    /** Gets a function by its pointer. */

    function getFunction(ptr) {
      return wrapFunction(table.get(ptr), setargc);
    }

    baseModule.getFunction = getFunction; // Pull basic exports to baseModule so code in preInstantiate can use them

    baseModule.memory = baseModule.memory || memory;
    baseModule.table = baseModule.table || table; // Demangle exports and provide the usual utility on the prototype

    return demangle(rawExports, Object.defineProperties(baseModule, {
      I8: {
        get: function get() {
          checkMem();
          return I8;
        }
      },
      U8: {
        get: function get() {
          checkMem();
          return U8;
        }
      },
      I16: {
        get: function get() {
          checkMem();
          return I16;
        }
      },
      U16: {
        get: function get() {
          checkMem();
          return U16;
        }
      },
      I32: {
        get: function get() {
          checkMem();
          return I32;
        }
      },
      U32: {
        get: function get() {
          checkMem();
          return U32;
        }
      },
      I64: {
        get: function get() {
          checkMem();
          return I64;
        }
      },
      U64: {
        get: function get() {
          checkMem();
          return U64;
        }
      },
      F32: {
        get: function get() {
          checkMem();
          return F32;
        }
      },
      F64: {
        get: function get() {
          checkMem();
          return F64;
        }
      }
    }));
  }
  /** Wraps a WebAssembly function while also taking care of variable arguments. */


  function wrapFunction(fn, setargc) {
    var wrap = function wrap() {
      setargc(arguments.length);
      return fn.apply(void 0, arguments);
    }; // adding a function to the table with `newFunction` is limited to actual WebAssembly functions,
    // hence we can't use the wrapper and instead need to provide a reference to the original


    wrap.original = fn;
    return wrap;
  }
  /** Instantiates an AssemblyScript module from a response using the specified imports. */

  function instantiateStreaming(_x, _x2) {
    return _instantiateStreaming.apply(this, arguments);
  }

  function _instantiateStreaming() {
    _instantiateStreaming = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee(response, imports) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = postInstantiate;
              _context.t1 = preInstantiate(imports || (imports = {}));
              _context.next = 4;
              return WebAssembly.instantiateStreaming(response, imports);

            case 4:
              _context.t2 = _context.sent.instance;
              return _context.abrupt("return", (0, _context.t0)(_context.t1, _context.t2));

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _instantiateStreaming.apply(this, arguments);
  }

  var instantiateStreaming_1 = instantiateStreaming;
  /** Demangles an AssemblyScript module's exports to a friendly object structure. */

  function demangle(exports, baseModule) {
    var module = baseModule ? Object.create(baseModule) : {};

    var setargc = exports._setargc || function () {};

    function hasOwnProperty(elem, prop) {
      return Object.prototype.hasOwnProperty.call(elem, prop);
    }

    var _loop = function _loop(internalName) {
      if (!hasOwnProperty(exports, internalName)) return "continue";
      var elem = exports[internalName];
      var parts = internalName.split(".");
      var curr = module;

      while (parts.length > 1) {
        var part = parts.shift();
        if (!hasOwnProperty(curr, part)) curr[part] = {};
        curr = curr[part];
      }

      var name = parts[0];
      var hash = name.indexOf("#");

      if (hash >= 0) {
        var className = name.substring(0, hash);
        var classElem = curr[className];

        if (typeof classElem === "undefined" || !classElem.prototype) {
          var ctor = function ctor() {
            var _ctor$prototype;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return ctor.wrap((_ctor$prototype = ctor.prototype).constructor.apply(_ctor$prototype, [0].concat(args)));
          };

          ctor.prototype = {};

          ctor.wrap = function (thisValue) {
            return Object.create(ctor.prototype, _defineProperty({}, thisPtr, {
              value: thisValue,
              writable: false
            }));
          };

          if (classElem) Object.getOwnPropertyNames(classElem).forEach(function (name) {
            return Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name));
          });
          curr[className] = ctor;
        }

        name = name.substring(hash + 1);
        curr = curr[className].prototype;

        if (/^(get|set):/.test(name)) {
          if (!hasOwnProperty(curr, name = name.substring(4))) {
            var getter = exports[internalName.replace("set:", "get:")];
            var setter = exports[internalName.replace("get:", "set:")];
            Object.defineProperty(curr, name, {
              get: function get() {
                return getter(this[thisPtr]);
              },
              set: function set(value) {
                setter(this[thisPtr], value);
              },
              enumerable: true
            });
          }
        } else {
          if (name === 'constructor') {
            curr[name] = wrapFunction(elem, setargc);
          } else {
            // for methods
            Object.defineProperty(curr, name, {
              value: function value() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                setargc(args.length);
                return elem.apply(void 0, [this[thisPtr]].concat(args));
              }
            });
          }
        }
      } else {
        if (/^(get|set):/.test(name)) {
          if (!hasOwnProperty(curr, name = name.substring(4))) {
            Object.defineProperty(curr, name, {
              get: exports[internalName.replace("set:", "get:")],
              set: exports[internalName.replace("get:", "set:")],
              enumerable: true
            });
          }
        } else if (typeof elem === "function") {
          curr[name] = wrapFunction(elem, setargc);
        } else {
          curr[name] = elem;
        }
      }
    };

    for (var internalName in exports) {
      var _ret = _loop(internalName);

      if (_ret === "continue") continue;
    }

    return module;
  }

  var encoded = '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';
  var optimized = new Promise(function (resolve) {
    var decoded = atob(encoded);
    var len = decoded.length;
    var bytes = new Uint8Array(len);

    for (var i = 0; i < len; i++) {
      bytes[i] = decoded.charCodeAt(i);
    }

    resolve(new Response(bytes, {
      status: 200,
      headers: {
        "Content-Type": "application/wasm"
      }
    }));
  });

  var api = {};
  var promise = instantiateStreaming_1(optimized).then(function (inst) {
    return Object.assign(api, {
      inst: inst
    });
  });
  var api$1 = (function () {
    return promise;
  });

  var circles = (function () {
    var pixelX = 1;
    var pixelY = 1;
    var lineWidth = 0;

    var callback = function callback() {};

    var circles = function circles(points, totalSegments) {
      var inst = api.inst;
      var in_buffer;
      var out_buffer;
      var edge_buffer;

      try {
        out_buffer = inst.newArray(Float32Array, totalSegments * 6, true);
        in_buffer = points.__forWASM ? points.__forWASM : inst.newArray(points);
        inst.circles(in_buffer, totalSegments, pixelX, pixelY, out_buffer);
        var edgeArray = null;

        if (lineWidth > 0) {
          edge_buffer = inst.newArray(Float32Array, totalSegments * 6, true);
          inst.edges(out_buffer, lineWidth, pixelX, pixelY, edge_buffer);
          edgeArray = inst.getArray(Float32Array, edge_buffer);
        }

        callback(inst.getArray(Float32Array, out_buffer), edgeArray);
      } finally {
        if (in_buffer) inst.freeArray(in_buffer);
        if (out_buffer) inst.freeArray(out_buffer);
        if (edge_buffer) inst.freeArray(edge_buffer);
      }
    };

    circles.pixelX = function () {
      if (!arguments.length) {
        return pixelX;
      }

      pixelX = arguments.length <= 0 ? undefined : arguments[0];
      return circles;
    };

    circles.pixelY = function () {
      if (!arguments.length) {
        return pixelY;
      }

      pixelY = arguments.length <= 0 ? undefined : arguments[0];
      return circles;
    };

    circles.lineWidth = function () {
      if (!arguments.length) {
        return lineWidth;
      }

      lineWidth = arguments.length <= 0 ? undefined : arguments[0];
      return circles;
    };

    circles.callback = function () {
      if (!arguments.length) {
        return callback;
      }

      callback = arguments.length <= 0 ? undefined : arguments[0];
      return circles;
    };

    return circles;
  });

  var shapes = (function () {
    var pixelX = 1;
    var pixelY = 1;
    var lineWidth = 0;
    var shape = [];

    var callback = function callback() {};

    var shapes = function shapes(points) {
      var inst = api.inst;
      var in_buffer;
      var shape_buffer;
      var out_buffer;
      var edge_buffer;

      try {
        var totalSegments = points.length / 3 * (shape.length / 2 - 1);
        out_buffer = inst.newArray(Float32Array, totalSegments * 6, true);
        in_buffer = points.__forWASM ? points.__forWASM : inst.newArray(points);
        shape_buffer = inst.newArray(shape);
        inst.shapes(in_buffer, shape_buffer, pixelX, pixelY, out_buffer);
        var edgeArray = null;

        if (lineWidth > 0) {
          edge_buffer = inst.newArray(Float32Array, totalSegments * 6, true);
          inst.edges(out_buffer, lineWidth, pixelX, pixelY, edge_buffer);
          edgeArray = inst.getArray(Float32Array, edge_buffer);
        }

        callback(inst.getArray(Float32Array, out_buffer), edgeArray);
      } finally {
        if (in_buffer) inst.freeArray(in_buffer);
        if (shape_buffer) inst.freeArray(shape_buffer);
        if (out_buffer) inst.freeArray(out_buffer);
        if (edge_buffer) inst.freeArray(edge_buffer);
      }
    };

    shapes.pixelX = function () {
      if (!arguments.length) {
        return pixelX;
      }

      pixelX = arguments.length <= 0 ? undefined : arguments[0];
      return shapes;
    };

    shapes.pixelY = function () {
      if (!arguments.length) {
        return pixelY;
      }

      pixelY = arguments.length <= 0 ? undefined : arguments[0];
      return shapes;
    };

    shapes.lineWidth = function () {
      if (!arguments.length) {
        return lineWidth;
      }

      lineWidth = arguments.length <= 0 ? undefined : arguments[0];
      return shapes;
    };

    shapes.shape = function () {
      if (!arguments.length) {
        return shape;
      }

      shape = arguments.length <= 0 ? undefined : arguments[0];
      return shapes;
    };

    shapes.callback = function () {
      if (!arguments.length) {
        return callback;
      }

      callback = arguments.length <= 0 ? undefined : arguments[0];
      return shapes;
    };

    return shapes;
  });

  var array_allocator = (function (size) {
    var inst = api.inst;
    var memory = inst.newArray(Float32Array, size, true);
    var array = inst.getArray(Float32Array, memory);
    array.__forWASM = memory;
    return array;
  });

  var pointData = (function () {
    var circles = false;

    var pointFn = function pointFn(d) {
      return {
        x: d.x,
        y: d.y,
        size: d.size
      };
    };

    var pointData = function pointData(data) {
      var dataPerPoint = circles ? 4 : 3;
      var result = array_allocator(data.length * dataPerPoint);
      var allSegments = 0;
      var index = 0;
      data.forEach(function (d) {
        var dataPoint = pointFn(d);
        result[index++] = dataPoint.x;
        result[index++] = dataPoint.y;
        var size = Math.floor(Math.sqrt(dataPoint.size) * 0.65);
        result[index++] = size;

        if (circles) {
          var segments = size * 2;
          result[index++] = segments;
          allSegments += segments;
        }
      });
      return {
        data: result,
        segmentCount: allSegments
      };
    };

    pointData.circles = function () {
      if (!arguments.length) {
        return circles;
      }

      circles = arguments.length <= 0 ? undefined : arguments[0];
      return pointData;
    };

    pointData.pointFn = function () {
      if (!arguments.length) {
        return pointFn;
      }

      pointFn = arguments.length <= 0 ? undefined : arguments[0];
      return pointData;
    };

    return pointData;
  });

  exports.circles = circles;
  exports.loadApi = api$1;
  exports.pointData = pointData;
  exports.shapes = shapes;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=d3fc-webgl-as.js.map
